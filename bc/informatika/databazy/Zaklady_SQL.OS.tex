\subsection{Základy SQL}
TODO: pøevzato od \uv{programátorù} z otázky \uv{SQL}, vzhledem k tomu, že u nás
se to jmenuje \uv{základy SQL} tak to možná nemusí být tak podrobné

Zdroje: slidy z pøednášek Databázové systémy a Databázové aplikace Dr. T. Skopala a Dr. M. Kopeckého.

\subsubsection*{Standardy SQL}

SQL (\emph{Structured query language}) je standardní jazyk pro pøístup k relaèním databázím (a dotazování nad nimi). Je zároveò jazykem pro definici dat (definition data language), vytváøení a modifikace schémat (tabulek), manipulaci s daty (data manipulation language), vkláání, aktualizace, mazání dat, øízení transakcí, definici integritních omezení aj. Jeho syntaxe odráží snahu o co nejpøirozenìjší formulace požadavkù -- je podobná anglickým \uv{vìtám}.

SQL je standard podle norem ANSI/ISO a existuje v nìkolika (zpìtnì kompatibilních) verzích (oznaèovaných podle roku uvedení):
\begin{description}
    \item[SQL 86] -- první \uv{nástøel}, prùnik implementací SQL firmy IBM
    \item[SQL 89] -- malá revize motivovaná komerèní sférou, mnoho detailù ponecháno implementaci
    \item[SQL 92] -- mnohem silnìjší a obsáhlejší jazyk. Zahrnuje už
    \begin{pitemize}
	\item modifikace schémat, tabulky s metadaty, 
	\item vnìjší spojení, množinové operace
	\item kaskádové mazání/aktualizace podle cizích klíèù, transakce
	\item kurzory, výjimky
    \end{pitemize}
    Standard existuje ve ètyøech verzích: Entry, Transitional, Intermediate a Full.
    \item[SQL 1999] -- pøináší mnoho nových vlastností, napø. 
    \begin{pitemize}	
	\item objektovì-relaèní rozšíøení
	\item nové datové typy -- reference, pole, full-text
	\item podpora pro externí datové soubory, multimédia
	\item triggery, role, programovací jazyk, regulární výrazy, rekurzivní dotazy ...
    \end{pitemize}
    \item[SQL 2003] -- další rozšíøení, napø. XML management
\end{description}

Komerèní systémy implementují SQL podle rùzných norem, nìkdy jenom SQL-92 Entry, dnes nejèastìji SQL-99, ale nikdy úplnì striktnì. Nìkteré vìci chybí a naopak mají všechny spoustu nepøenositelných rozšíøení -- napø. specifická rozšíøení pro procedurální, transakèní a další funkcionalitu (T-SQL (Microsoft SQL Server), PL-SQL (Oracle) ). S novými verzemi se kompatibilita zlepšuje, èasto je možné používat obojí syntax. Pøenos aplikace za bìhu na jinou platformu je ale stále velice nároèný -- a to tím nároènìjší, èím víc vìcí mimo SQL-92 Entry obsahuje.Pro otestování, zda je špatnì syntax SQL, nebo zda jen daná databázová platforma nepodporuje nìkterý prvek, slouží SQL validátory (které testují SQL podle norem.


\subsubsection*{Dotazy v SQL}

Hlavním nástrojem dotazù v SQL je pøíkaz \texttt{SELECT}. Sdílí prvky relaèního kalkulu i relaèní algebry -- obsahuje práci se sloupci, kvantifikátory a agregaèní funkce z relaèního kalkulu a další operace -- projekce, selekce, spojení, množinové operace -- z relaèní algebry. Na rozdíl od striktní formulace relaèního modelu databáze povoluje duplikátní øádky a NULLové hodnoty atributù.

Netøídìný dotaz v SQL sestává z:
\begin{pitemize}
    \item pøíkazu(ù) \texttt{SELECT} (hlavní logika dotazování), to obsahuje vždy
    \item mùže obsahovat i množinové operace nad výsledky pøíkazù \texttt{SELECT} -- \texttt{UNION}, \texttt{INTERSECTION} ...
\end{pitemize}
Výsledky nemají definované uspoøádání (resp. jejich poøadí je urèeno implementací vyhodnocení dotazu).

Pøíkaz \texttt{SELECT} vypadá následovnì (tato verze už zahrnuje i tøídìní výsledkù):
\begin{verbatim}
SELECT [DISTINCT]
 výraz1 [[AS] c_alias1] [, ...]
FROM
 zdroj1 [[AS] t_alias1] [, ...]
[WHERE podmínka_ø]
[GROUP BY výraz_g1 [, …]
[HAVING podmínka_s]]
[ORDER BY výraz_o1 [, …] ASC/DESC]
\end{verbatim}
Kde
\begin{pitemize}
    \item výrazy mohou být sloupce, sloupce s agregaèními funkcemi, výsledky dalších funkcí ...

\noindent \texttt{ výraz = <název sloupce>, <konstanta>, \\
 (DISTINCT) COUNT(~<název sloupce>~),\\
{}[DISTINCT] [~SUM~|~AVG~](~<výraz>~),\\
{}[~MIN~|~MAX~](~<výraz>~)}\\
a navíc lze použít operátory $+,-,*,/$.

    \item zdroje jsou tabulky nebo vnoøené selecty
    \item výrazy i zdroje být pøejmenovány pomocí \texttt{AS}, napø. pro odkazování uvnitø dotazu nebo jména na výstupu (od SQL-92)
    \item podmínka je logická podmínka (spojovaná logickými spojkami \texttt{AND, OR}) na hodnoty dat ve zdrojích:

\texttt{podmínka = <výraz> BETWEEN <x> AND <y>, <výraz> LIKE "\%\_ ... ",\\
<výraz> IS [NOT] NULL,\\
<výraz> > = <> <= < > [<výraz>/ ALL / ANY <dotaz>],\\
<výraz> NOT IN [<seznam hodnot> / <dotaz>], EXIST ( <dotaz> )}

    \item \texttt{GROUP BY} znamená agregaci podle unikátních hodnot jmenovaných sloupcù (v ostatních sloupcích vznikají množiny hodnot, které se spolu s onìmi unikátnímí vyskytují na stejných øádkách
    \item \texttt{HAVING} oznaèuje podmínku na agregaci
    \item \texttt{ORDER BY} definuje, podle hodnot ve kterých sloupcích nebo podle kterých jiných výrazù nad nimi provedených se má výsledek setøídit (\texttt{ASC} požaduje vzestupné setøídìní, \texttt{DESC} sestupné).
\end{pitemize}

SQL nemá pøíkaz na omezení rozsahu na nìkteré øádky (jako napø. \uv{potøebuji jen 50.-100. øádek výpisu}), a to lze øešit buï složitì standardnì (poèítání kolik hodnot je menších než vybraná, navíc nároèné na hardware) nebo pomocí nìkterého nepøenositelného rozšíøení.

\medskip\noindent
Poøadí vyhodnocování jednoho pøíkazu \texttt{SELECT} (nebereme v úvahu optimalizace):
\begin{penumerate}
    \item Nejprve se zkombinují data ze všech zdrojù (tabulek, pohledù, poddotazù). Pokud jsou oddìleny èárkami, provede se kartézský souèin (to samé co \texttt{CROSS JOIN}), v SQL-92 a vyšším i složitìjší spojení -- \texttt{JOIN ON} (vnitøní spojení podle podmínky), \texttt{NATURAL JOIN} (\uv{pøirozené} spojení podle stejných hodnot stejnì pojmenovaných sloupcù), \texttt{OUTER JOIN} (\uv{vnìjší} spojení, do kterého jsou zahrnuty i záznamy, pro které v jednom ze zdrojù není nalezeno nic, co by odpovídalo podmínce, doplnìnné NULLovými hodnotami) atd.
    \item Vyøadí se vzniklé øádky, které nevyhovují podmínce (\texttt{WHERE})
    \item Zbylé øádky se seskupí do skupin se stejnými hodnotami uvedených výrazù (\texttt{HAVING}), každá skupina obsahuje atomické sloupce s hodnotami uvedených výrazù a množinové sloupce se skupinami ostatních hodnot sloupcù.
    \item Vyøadí se skupiny, nevyhovující podmínce (\texttt{HAVING})
    \item Výsledky se setøídí podle požadavkù
    \item Vygeneruje se výstup s požadovanými hodnotami
    \item V pøípadì \texttt{DISTINCT} se vyøadí duplicitní øádky
\end{penumerate}


\begin{e}{Poznámka}{0}{0}
\begin{pitemize}
    \item Klauzule \texttt{GROUP BY} setøídí pøed vytvoøením skupin všechny øádky dle výrazù v klauzuli. Proto by se mìl seskupovat co nejmenší možný poèet øádek. Pokud je možné øádky odfiltrovat pomocí WHERE, je výsledek efektivnìjší, než následné odstraòování celých skupin.
    \item  Klauzule \texttt{DISTINCT} tøídí výsledné záznamy (pøed operací ORDER BY), aby našla duplicitní záznamy. Pokud to jde, je vhodné se bez ní obejít.
    \item Klauzule \texttt{ORDER BY} by mìla být použita jen v nutných pøípadech. Není pøíliš vhodné ji používat v definicích pohledù, nad kterými se dále dìlají další dotazy
\end{pitemize}
\end{e}


\subsubsection*{Definice a manipulace s daty, ostatní pøíkazy}

Standard SQL podporuje nìkolik druhù datových typù:
\begin{pitemize}
    \item textové v národní a globální (UTF) znakové sadì (nìkolika druhù -- promìnné a pevné délky): \texttt{CHARACTER(n)}, \texttt{NCHAR(n)},
    \texttt{CHAR VARYING(n)}
    \item èíselné typy -- \texttt{ NUMERIC(p[,s]), INTEGER, INT, SMALLINT,\\  FLOAT(presnost), REAL, DOUBLE PRECISION}
    \item datumové typy -- \texttt{DATE, TIME, TIMESTAMP, TIMESTAMP(presnost\_sekund) WITH TIMEZONE}
\end{pitemize}
Databázové servery ne vždy podporují všechny uvedené typy. Nemusí je podporovat nativnì, nìkdy si pouze \uv{pøeloží} název typu na podobný nativnì podporovaný typ.

\medskip
\begin{obecne}{Pøíkaz \texttt{CREATE TABLE}}
Tento pøíkaz slouží k vytvoøení nové tabulky. Je nutné definovat její název, atributy a jejich domény (datové typy); dále je mo6né definovat integritní omezení (klíèe, cizí klíèe, odkazy, podmínky). Pøíkaz vypadá následovnì:
\begin{center}
\texttt{CREATE TABLE <název> <def. sloupce/i.o. tabulky, ...> }
\end{center}
A uvnitø potom
\begin{verbatim}
def. sloupce = <název> <dat.typ> 
    [DEFAULT NULL|<hodnota>] [<i.o.sloupce>] 
dat.typ = [VARCHAR(n) | BIT(n) | INTEGER | FLOAT | DECIMAL ...] 
i.o.sloupce = [CONSTRAINT <jméno>] [NOT NULL / UNIQUE / PRIMARY KEY], 
    REFERERENCES <tabulka>(<sloupec>) <akce>, CHECK <podmínka> 
akce = [ON UPDATE / ON DELETE] 
    [CASCADE / SET NULL / SET DEFAULT / NO ACTION(hlášení chyby) ] 
i.o.tabulky = UNIQUE, PRIMARY KEY <sloupec, ... >, 
    FOREIGN KEY <sloupec, ... >, 
    REFERENCES <tabulka>(<sloupec, ... >), 
    CHECK( <podmínka> )
\end{verbatim}
\end{obecne}

\medskip
\begin{obecne}{Pøíkazy pro manipulaci se schématem}
\begin{pitemize}
    \item Úprava tabulky:
\begin{verbatim}
ALTER TABLE <název> ADD {COLUMN} <def.sloupce>, ADD <i.o.tabulky>, 
    ALTER COLUMN <sloupec> [ SET / DROP ], DROP COLUMN <sloupec>, 
    DROP CONSTRAINT <jméno i.o.> 
\end{verbatim}
    \item Smazání tabulky (není to samé jako vymazání všech dat z tabulky!):
\begin{verbatim}
DROP TABLE <tabulka> 
\end{verbatim}
    \item Vytvoøení \uv{pohledu} -- navenek se chová jako tabulka, ale vnitønì se pøi každém dotazu provede vnoøený dotaz (který definicí pohledu zapisuji):
\begin{verbatim}
CREATE VIEW <název "tabulky"> ( <sloupec, ... > ) 
    AS <dotaz> {WITH [ LOCAL / CASCADED ] CHECK OPTION }
\end{verbatim}
    Nìkteré databázové platformy umožòují do takto vytvoøených pohledù i zapisovat.
\end{pitemize}
\end{obecne}

\medskip
\begin{obecne}{Pøíkazy pro manipulaci s daty}
\begin{pitemize}
    \item Vložení nových dat do tabulky
\begin{verbatim}
INSERT INTO <tabulka> ( <sloupec, ... > ) 
    [VALUES ( <výraz, ... > ) / (<dotaz>) ] 
\end{verbatim}
    \item Úprava dat (na øádcích které vyhovují podmínce se nastaví zadané hodnoty vybraným sloupcùm):
\begin{verbatim}
UPDATE <tabulka> SET 
    ( <sloupec> = [ NULL / <výraz> / <dotaz> ] , ... ) 
    WHERE (<podmínka>) 
\end{verbatim}
    \item Smazání øádkù vyhovujících podmínce z tabulky:
\begin{verbatim}
DELETE FROM <tabulka> ( WHERE <podmínka> ) 
\end{verbatim}
\end{pitemize}
\end{obecne}
