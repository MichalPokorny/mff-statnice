\subsection{Generické programování – šablony a generika}

Základní myšlenkou, která se skrývá za pojmem generické programování, je rozdìlení kódu programu na algoritmus a datové typy takovým zpùsobem, aby bylo možné zápis kódu algoritmu chápat jako obecný, bez ohledu na to, nad jakými datovými typy pracuje. Konkrétní kód algoritmu se z nìj stává dosazením datového typu.

U kompilovaných jazykù dochází k rozvinutí kódu v dobì pøekladu. Typickým pøíkladem jazyka, který podporuje tuto formu generického programování, je jazyk C++. Mechanismem, který zde generické programování umožòuje, 
jsou takzvané šablony (templates).

\medskip
\begin{poznamkaN}{Metaprogramování a Generika}
It differs from normal programming in that it somehow invokes within the language a metaprogramming facility. Because it happens as an extension of the language, new semantics are introduced and the language is enriched in this process. It is closely related to metaprogramming, but does not involve the generation of source code (none, at least, that is visible to the user of the language). It is different from programming with macros as well, as the latter refers to textual search-and-replace and is not part of the grammar of the language but implemented by a pre-processor. One exception to this is the macro facility in Common Lisp, in which macros operate on parse trees rather than text.

Obyèejné fce mají pøednost pøed generickými???
\end{poznamkaN}

\begin{definiceN}{Šablony}
Template metaprogramming is a metaprogramming technique in which templates are used by a compiler to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled. The output of these templates include compile-time constants, data structures, and complete functions. The use of templates can be thought of as compile-time execution. The technique is used by a number of languages, the best-known being C++, but also Curl, D, and XL.
\end{definiceN}

\begin{prikladN}{Tøída parametrizovaná typem (kontejner)}
As an example of the benefits of generic programming, when creating containers of objects it is common to write specific implementations for each datatype contained, even if the code is virtually identical except for different datatypes. Instead, a possible declaration using generic programming could be to define a template class (using the C++ idiom):
\begin{verbatim}
  template<typename T> 
  class List 
  { 
    T x;
    List<T> *next;
  };
  
  List<Animal> list_of_animals;
  List<Car> list_of_cars;
  
  ...
  
  conductor = root;
  while ( conductor != NULL ) {
    cout<< conductor->x;
    conductor = conductor->next;
  }
\end{verbatim}
Above T represents the type to be instantiated. The list generated is then treated as a list of whichever type is specified. These "containers-of-type-T", commonly called generics, are a generic programming technique that allows the defining of a class that takes and contains different datatypes (not to be confused with polymorphism, which is the algorithmic usage of exchangeable sub-classes) as long as certain contracts such as subtypes and signature are kept. Although the example above is the most common use of generic programming, and some languages implement only this aspect of it, generic programming as a concept is not limited to generics. 
\end{prikladN}

\begin{prikladN}{Typovì nezávislá funkce}
Another applicaton is type-independent functions as in the Swap example below:
\begin{verbatim}
  template<typename T>
  void Swap(T & a, T & b) //"&" passes parameters by reference
  {
     T temp = b;
     b = a;
     a = temp;
  }
  
  string hello = "world!", world = "Hello, ";
  Swap( world, hello );
  cout << hello << world << endl; //Output is "Hello, world!"
\end{verbatim}
\end{prikladN}

\begin{prikladN}{Faktoriál pomocí šablon}
\begin{verbatim}
  template <int N>
  struct Factorial 
  {
      enum { value = N * Factorial<N - 1>::value };
  };
   
  template <>
  struct Factorial<0> 
  {
      enum { value = 1 };
  };
   
  // použití:
  int x = Factorial<4>::value; // == 24
  int y = Factorial<0>::value; // == 1
\end{verbatim}
\end{prikladN}


\begin{prikladN}{traits}
Programovací paradigma využívající šablony, ze kterých nejsou vytváøeny objekty. Urèeny k doplnìní informací o nìjakém typu.
\\\\Obsahují pouze:
\begin{pitemize}
\item Definice typù
\item Statické funkce
\end{pitemize}

\begin{verbatim}
  template< typename T > 
  struct is_void{ 
    static const bool value = false;
  };
  
  template<> 
  struct is_void< void >{ 
    static const bool value = true; 
  };
  
  // použití:
  is_void<int>::value; // false
  is_void<void>::value; // true
\end{verbatim}
\end{prikladN}
\newpage
\begin{prikladN}{policy classes}
Urèeny k definování urèitého chování. Jous to tøídy, ze kterých obvykle nejsou vytváøeny objekty a jsou pøedávány jako parametr šablonám. Defaultní hodnotou parametru èasto bývá šablona traits. Hlavnì spojené s C++ (v ostatních jazycích se zatím nerozšíøilo).
\begin{verbatim}
  template < typename output_policy, typename language_policy >
  class HelloWorld : public output_policy, public language_policy
  {
      using output_policy::Print;
      using language_policy::Message;
       
      public: void Run() //behaviour method
      {
          //two policy methods
          Print( Message() );
      }
  };
   
  class OutputPolicy_WriteToCout
  {
   protected:
      template< typename message_type >
      void Print( message_type message )
      {
          std::cout << message << std::endl;
      }
  };
   
  class LanguagePolicy_English
  {
      protected: std::string Message() { return "Hello, World!"; }
  };
   
  class LanguagePolicy_German
  {
      protected: std::string Message() { return "Hallo Welt!"; }
  };
   
  int main()
  {
      /* example 1 */
      HelloWorld<OutputPolicy_WriteToCout, LanguagePolicy_English>  hello_world;
      hello_world.Run(); // Prints "Hello, World!"
   
     /* example 2 
      * does the same but uses another policy, the language has changed
      */
      HelloWorld<OutputPolicy_WriteToCout, LanguagePolicy_German> hello_world2;
      hello_world2.Run(); // Prints "Hallo Welt!"
  }
\end{verbatim}
\end{prikladN}
\newpage
\begin{definiceN}{Dynamický (run-time) polymorfismus}
Dìdìní + VMT = flexibilita.
Pøípadnì jeho varianta s šablonami:
\begin{verbatim}
class Base
{
public:
    virtual void method() { std::cout << "Base"; }
    virtual ~Base() {}
};
 
class Derived : public Base
{
public:
    virtual void method() { std::cout << "Derived"; }
};
 
int main()
{
    Base *pBase = new Derived;
    pBase->method(); //outputs "Derived"
    delete pBase;
    return 0;
}
\end{verbatim}
\end{definiceN}

\begin{definiceN}{Statický (compile-time) polymorfismus}
Je pøetìžování fukcí a operátorù, øeší se pøi kompilaci = rychlost.
Pøípadnì jeho varianta s šablonami:
\begin{verbatim}
template <class Derived>
struct base
{
    void interface()
    {
         // ...
         static_cast<Derived*>(this)->implementation();
         // ...
    }
};
 
struct derived : base<derived>
{
     void implementation();
};
\end{verbatim}
Lze tak dosáhnout podobných vìcí jako s VMT.
\end{definiceN}

\begin{obecne}{Použití v programovacích jazycích}
The template construct of C++ used in the examples above is widely cited as the generic programming construct that popularized the notion among programmers and language designers and provides full support for all generic programming idioms. D also offers fully generic-capable templates based on the C++ precedent but with a simplified syntax. Java has provided generic programming facilities syntactically based on C++'s since the introduction of J2SE 5.0 and implements the generics, or "containers-of-type-T", subset of generic programming.
\end{obecne}

\begin{reportN}{IP 21.6.2011} Co je to generické programování, k èemu se používá a v èem spoèívají jeho výhody?

Napište struènou implementaci generické tøídy List nebo HashTable.

Popište implementaci v C++ a Javì (asi by staèil i C#, ale v zadání byla explicitnì napsaná java).
\end{reportN}

\begin{reportN}{IP 21.6.2011 ($<$2007)} Popiste sablony
\\Jak jsou implementovany (popiste jak jsou implementovany v C++ nebo Java) (to som teda fakt netusil)
\end{reportN}

\begin{reportN}{IOI 21.6.2011 ($<$2007)}
Co je to generické programování, k èemu se používá a v èem spoèívají jeho výhody?

Napište struènou implementaci generické tøídy List nebo HashTable.
\end{reportN}

\begin{reportN}{Yaghob}
Co je to traits a policy classes, co je to statický polymorfismus apod. Nakonec jsem to nìjak vymyslel a shodli jsme se na tom, že to vím, takže taky za 1.
\end{reportN}
